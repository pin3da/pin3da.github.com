
<!DOCTYPE html>
<html>
  <head>
    <title>ZeroMQ + Node</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(//fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(//fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(//fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      .red { color: #fa0000; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# ZeroMQ + Node.js
## (or How to connect your backend)

*Manuel Pineda*
[@pin3da_](https://twitter.com/pin3da_)
[pin3da at github](https://github.com/pin3da)

---

# Why is this necesary ?


---

# Why ZeroMQ ?

#### What people say : .red[*]

--

- "I suspect that zeromq is reverse engineered from an alien spacecraft. — @no_structure"

- "ZeroMQ could very well be the new way in how we connect our components — Nicholas Piël"

- "Once again, ZeroMQ surprised me by making it trivial — Oliver Smith"

.footnote[.red.bold[*] Taken from http://zeromq.org/intro:what-people-say]

---

# Why ZeroMQ ?


- How do we handle I/O? Does our application block, or do we handle I/O in the background? This is a key design decision. Blocking I/O creates architectures that do not scale well. But background I/O can be very hard to do right.

- How do we handle dynamic components, i.e., pieces that go away temporarily? Do we formally split components into "clients" and "servers" and mandate that servers cannot disappear? What then if we want to connect servers to servers? Do we try to reconnect every few seconds?

- How do we represent a message on the wire? How do we frame data so it's easy to write and read, safe from buffer overflows, efficient for small messages, yet adequate for the very largest videos of dancing cats wearing party hats?

- How do we handle messages that we can't deliver immediately? Particularly, if we're waiting for a component to come back online? Do we discard messages, put them into a database, or into a memory queue?

- Where do we store message queues? What happens if the component reading from a queue is very slow and causes our queues to build up? What's our strategy then?

- How do we handle lost messages? Do we wait for fresh data, request a resend, or do we build some kind of reliability layer that ensures messages cannot be lost? What if that layer itself crashes?


---

# Why ZeroMQ ?


- What if we need to use a different network transport. Say, multicast instead of TCP unicast? Or IPv6? Do we need to rewrite the applications, or is the transport abstracted in some layer?

- How do we route messages? Can we send the same message to multiple peers? Can we send replies back to an original requester?

- How do we write an API for another language? Do we re-implement a wire-level protocol or do we repackage a library? If the former, how can we guarantee efficient and stable stacks? If the latter, how can we guarantee interoperability?

- How do we represent data so that it can be read between different architectures? Do we enforce a particular encoding for data types? How far is this the job of the messaging system rather than a higher layer?

- How do we handle network errors? Do we wait and retry, ignore them silently, or abort?

---

# How does it work ?


---

# Patterns and sockets


---

# Request-Reply

![reqrep](https://github.com/imatix/zguide/raw/master/images/fig2.png)

---

# Publish-Subscribe

![publishsubscribe](https://github.com/imatix/zguide/raw/master/images/fig4.png)


---

# Parallel Pipeline

![pipeline](https://github.com/imatix/zguide/raw/master/images/fig5.png)

---

# Node

```
 npm install zmq
```


---

# Asynchronous power


---

# Connect Node with other languages using ZeroMQ (C/C++ example)


    </textarea>
    <script src="//gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
